"""
Agent 4 - Audio Pipeline Agent

This agent generates TTS audio from script text using OpenAI's TTS API.
It receives a script with hook, concept, process, and conclusion parts,
generates audio for each.

Called via orchestrator in Full Test mode.
"""
import asyncio
import json
import time
import logging
from typing import Optional, Dict, Any, Callable, Awaitable
from sqlalchemy.orm import Session
from sqlalchemy import text
from app.services.websocket_manager import WebSocketManager
from app.services.storage import StorageService
from app.agents.audio_pipeline import AudioPipelineAgent
from app.agents.base import AgentInput

logger = logging.getLogger(__name__)


async def agent_4_process(
    websocket_manager: Optional[WebSocketManager],
    user_id: str,
    session_id: str,
    supersessionid: str,
    script: Dict[str, Any],
    voice: str = "alloy",
    audio_option: str = "tts",
    storage_service: Optional[StorageService] = None,
    agent2_data: Optional[Dict[str, Any]] = None,
    db: Optional[Session] = None,
    status_callback: Optional[Callable[[str, str, str, str, int], Awaitable[None]]] = None
) -> Dict[str, Any]:
    """
    Agent4: Audio Pipeline - generates TTS audio from script.

    Args:
        websocket_manager: WebSocket manager for status updates (deprecated, use status_callback)
        user_id: User identifier
        session_id: Session identifier
        supersessionid: Super session identifier (generated by Agent2)
        script: Script with hook, concept, process, conclusion parts
        voice: TTS voice to use (default: alloy)
        audio_option: Audio generation option (tts, upload, none, instrumental)
        storage_service: Storage service for S3 operations
        agent2_data: Data passed from Agent2 (template_id, diagram_id, script_id, etc.)
        db: Database session for querying video_session table
        status_callback: Callback function for sending status updates to orchestrator

    Returns:
        Dict with audio generation results
    """
    # Initialize storage service if not provided
    if storage_service is None:
        storage_service = StorageService()
    
    # Query video_session table if db is provided
    if db is not None:
        try:
            result = db.execute(
                text(
                    "SELECT * FROM video_session WHERE id = :session_id AND user_id = :user_id"
                ),
                {"session_id": session_id, "user_id": user_id},
            ).fetchone()
            
            if not result:
                raise ValueError(f"Video session not found for session_id={session_id} and user_id={user_id}")
            
            # Convert result to dict
            if hasattr(result, "_mapping"):
                video_session_data = dict(result._mapping)
            else:
                video_session_data = {
                    "id": getattr(result, "id", None),
                    "user_id": getattr(result, "user_id", None),
                    "topic": getattr(result, "topic", None),
                    "confirmed_facts": getattr(result, "confirmed_facts", None),
                    "generated_script": getattr(result, "generated_script", None),
                }
            
            # Extract script from video_session if not provided
            if not script and video_session_data.get("generated_script"):
                from app.agents.agent_2 import extract_script_from_generated_script
                extracted_script = extract_script_from_generated_script(video_session_data.get("generated_script"))
                if extracted_script:
                    script = extracted_script
            
            logger.info(f"Agent4 loaded video_session data for session {session_id}")
        except Exception as e:
            logger.error(f"Agent4 failed to query video_session: {e}")
            raise

    # Helper function to send status (via callback or websocket_manager)
    async def send_status(agentnumber: str, status: str, **kwargs):
        """Send status update via callback or websocket_manager."""
        timestamp = int(time.time() * 1000)
        
        if status_callback:
            # Use callback (preferred - goes through orchestrator)
            await status_callback(
                agentnumber=agentnumber,
                status=status,
                userID=user_id,
                sessionID=session_id,
                timestamp=timestamp,
                **kwargs
            )
        elif websocket_manager:
            # Fallback to direct websocket (for backwards compatibility)
            status_data = {
                "agentnumber": agentnumber,
                "userID": user_id,
                "sessionID": session_id,
                "status": status,
                "timestamp": timestamp,
                **kwargs
            }
            await websocket_manager.send_progress(session_id, status_data)
    
    # Helper function to create JSON status file in S3
    async def create_status_json(agent_number: str, status: str, status_data: dict):
        """Create a JSON file in S3 with status data."""
        if not storage_service.s3_client:
            return  # Skip if storage not configured

        timestamp = int(time.time() * 1000)  # Milliseconds timestamp
        filename = f"agent_{agent_number}_{status}_{timestamp}.json"
        # Use scaffold_test/{userId}/{sessionId}/agent4/ path
        s3_key = f"scaffold_test/{user_id}/{session_id}/agent4/{filename}"

        try:
            json_content = json.dumps(status_data, indent=2).encode('utf-8')
            storage_service.s3_client.put_object(
                Bucket=storage_service.bucket_name,
                Key=s3_key,
                Body=json_content,
                ContentType='application/json'
            )
        except Exception as e:
            # Log but don't fail the pipeline if JSON creation fails
            logger.warning(f"Failed to create status JSON file: {e}")

    result_data = {}

    try:
        # Report starting status
        await send_status("Agent4", "starting", supersessionID=supersessionid)
        status_data = {
            "agentnumber": "Agent4",
            "userID": user_id,
            "sessionID": session_id,
            "supersessionID": supersessionid,
            "status": "starting",
            "timestamp": int(time.time() * 1000)
        }
        await create_status_json("4", "starting", status_data)

        logger.info(f"Agent4 starting audio generation for session {session_id}")

        # Report processing status
        await send_status("Agent4", "processing", supersessionID=supersessionid)
        status_data = {
            "agentnumber": "Agent4",
            "userID": user_id,
            "sessionID": session_id,
            "supersessionID": supersessionid,
            "status": "processing",
            "timestamp": int(time.time() * 1000)
        }
        await create_status_json("4", "processing", status_data)

        # Create AudioPipelineAgent instance
        audio_agent = AudioPipelineAgent(
            db=None,  # No DB needed for TTS
            storage_service=storage_service,
            websocket_manager=websocket_manager
        )

        # Create agent input
        agent_input = AgentInput(
            session_id=session_id,
            data={
                "script": script,
                "voice": voice,
                "audio_option": audio_option,
                "user_id": user_id
            }
        )

        # Process audio generation
        audio_result = await audio_agent.process(agent_input)

        if not audio_result.success:
            raise Exception(audio_result.error or "Audio generation failed")

        result_data = audio_result.data

        # Upload audio files to S3 if they have local filepaths
        if result_data.get("audio_files"):
            for audio_file in result_data["audio_files"]:
                if audio_file.get("filepath") and audio_file["part"] != "music":
                    # Upload to S3 - use scaffold_test/{userId}/{sessionId}/agent4/ path
                    s3_key = f"scaffold_test/{user_id}/{session_id}/agent4/audio_{audio_file['part']}.mp3"
                    try:
                        with open(audio_file["filepath"], "rb") as f:
                            storage_service.s3_client.put_object(
                                Bucket=storage_service.bucket_name,
                                Key=s3_key,
                                Body=f.read(),
                                ContentType='audio/mpeg'
                            )
                        # Generate presigned URL
                        audio_file["url"] = storage_service.generate_presigned_url(s3_key, expires_in=86400)  # 24 hours for testing
                        logger.info(f"Uploaded audio file to S3: {s3_key}")
                    except Exception as e:
                        logger.warning(f"Failed to upload audio file to S3: {e}")

        # Report finished status
        finished_kwargs = {
            "supersessionID": supersessionid,
            "fileCount": len(result_data.get("audio_files", [])),
            "progress": 100,
            "cost": result_data.get("total_cost", 0)
        }
        await send_status("Agent4", "finished", **finished_kwargs)
        status_data = {
            "agentnumber": "Agent4",
            "userID": user_id,
            "sessionID": session_id,
            "supersessionID": supersessionid,
            "status": "finished",
            "timestamp": int(time.time() * 1000),
            **finished_kwargs
        }
        await create_status_json("4", "finished", status_data)

        logger.info(f"Agent4 completed audio generation for session {session_id}")

        # Return result data for orchestrator
        return {
            "status": "success",
            "audio_files": result_data.get("audio_files", []),
            "total_duration": result_data.get("total_duration", 0),
            "total_cost": result_data.get("total_cost", 0),
            "supersessionid": supersessionid
        }

    except Exception as e:
        # Report error status and stop pipeline
        error_kwargs = {
            "error": str(e),
            "reason": f"Agent4 failed: {type(e).__name__}",
            "supersessionID": supersessionid if 'supersessionid' in locals() else None
        }
        await send_status("Agent4", "error", **error_kwargs)
        error_data = {
            "agentnumber": "Agent4",
            "userID": user_id,
            "sessionID": session_id,
            "status": "error",
            "timestamp": int(time.time() * 1000),
            **error_kwargs
        }
        await create_status_json("4", "error", error_data)
        logger.error(f"Agent4 failed for session {session_id}: {e}")
        raise  # Stop pipeline on error
