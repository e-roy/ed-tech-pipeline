"""
Agent 4 - Audio Pipeline Agent

This agent generates TTS audio from script text using OpenAI's TTS API.
It receives a script with hook, concept, process, and conclusion parts,
generates audio for each, and then triggers Agent 5.

Called via API from Agent 2.
"""
import asyncio
import json
import time
import logging
from typing import Optional, Dict, Any
from app.services.websocket_manager import WebSocketManager
from app.services.storage import StorageService
from app.agents.audio_pipeline import AudioPipelineAgent
from app.agents.base import AgentInput

logger = logging.getLogger(__name__)


async def agent_4_process(
    websocket_manager: WebSocketManager,
    user_id: str,
    session_id: str,
    supersessionid: str,
    script: Dict[str, Any],
    voice: str = "alloy",
    audio_option: str = "tts",
    storage_service: Optional[StorageService] = None,
    agent2_data: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Agent4: Audio Pipeline - generates TTS audio from script.

    Args:
        websocket_manager: WebSocket manager for status updates
        user_id: User identifier
        session_id: Session identifier
        supersessionid: Super session identifier (generated by Agent2)
        script: Script with hook, concept, process, conclusion parts
        voice: TTS voice to use (default: alloy)
        audio_option: Audio generation option (tts, upload, none, instrumental)
        storage_service: Storage service for S3 operations
        agent2_data: Data passed from Agent2 (template_id, diagram_id, script_id, etc.)

    Returns:
        Dict with audio generation results
    """
    # Initialize storage service if not provided
    if storage_service is None:
        storage_service = StorageService()

    # Helper function to create JSON status file in S3
    async def create_status_json(agent_number: str, status: str, status_data: dict):
        """Create a JSON file in S3 with status data."""
        if not storage_service.s3_client:
            return  # Skip if storage not configured

        timestamp = int(time.time() * 1000)  # Milliseconds timestamp
        filename = f"agent_{agent_number}_{status}_{timestamp}.json"
        s3_key = f"scaffold_test/{user_id}/{supersessionid}/{filename}"

        try:
            json_content = json.dumps(status_data, indent=2).encode('utf-8')
            storage_service.s3_client.put_object(
                Bucket=storage_service.bucket_name,
                Key=s3_key,
                Body=json_content,
                ContentType='application/json'
            )
        except Exception as e:
            # Log but don't fail the pipeline if JSON creation fails
            logger.warning(f"Failed to create status JSON file: {e}")

    result_data = {}

    try:
        # Report starting status
        status_data = {
            "agentnumber": "Agent4",
            "userID": user_id,
            "sessionID": session_id,
            "supersessionID": supersessionid,
            "status": "starting",
            "timestamp": int(time.time() * 1000)
        }
        await websocket_manager.send_progress(session_id, status_data)
        await create_status_json("4", "starting", status_data)

        logger.info(f"Agent4 starting audio generation for session {session_id}")

        # Report processing status
        status_data = {
            "agentnumber": "Agent4",
            "userID": user_id,
            "sessionID": session_id,
            "supersessionID": supersessionid,
            "status": "processing",
            "timestamp": int(time.time() * 1000)
        }
        await websocket_manager.send_progress(session_id, status_data)
        await create_status_json("4", "processing", status_data)

        # Create AudioPipelineAgent instance
        audio_agent = AudioPipelineAgent(
            db=None,  # No DB needed for TTS
            storage_service=storage_service,
            websocket_manager=websocket_manager
        )

        # Create agent input
        agent_input = AgentInput(
            session_id=session_id,
            data={
                "script": script,
                "voice": voice,
                "audio_option": audio_option,
                "user_id": user_id
            }
        )

        # Process audio generation
        audio_result = await audio_agent.process(agent_input)

        if not audio_result.success:
            raise Exception(audio_result.error or "Audio generation failed")

        result_data = audio_result.data

        # Upload audio files to S3 if they have local filepaths
        if result_data.get("audio_files"):
            for audio_file in result_data["audio_files"]:
                if audio_file.get("filepath") and audio_file["part"] != "music":
                    # Upload to S3
                    s3_key = f"scaffold_test/{user_id}/{supersessionid}/audio_{audio_file['part']}.mp3"
                    try:
                        with open(audio_file["filepath"], "rb") as f:
                            storage_service.s3_client.put_object(
                                Bucket=storage_service.bucket_name,
                                Key=s3_key,
                                Body=f.read(),
                                ContentType='audio/mpeg'
                            )
                        # Generate presigned URL
                        audio_file["url"] = storage_service.generate_presigned_url(s3_key, expires_in=3600)
                        logger.info(f"Uploaded audio file to S3: {s3_key}")
                    except Exception as e:
                        logger.warning(f"Failed to upload audio file to S3: {e}")

        # Report finished status
        status_data = {
            "agentnumber": "Agent4",
            "userID": user_id,
            "sessionID": session_id,
            "supersessionID": supersessionid,
            "status": "finished",
            "audioFiles": len(result_data.get("audio_files", [])),
            "totalDuration": result_data.get("total_duration", 0),
            "totalCost": result_data.get("total_cost", 0),
            "timestamp": int(time.time() * 1000)
        }
        await websocket_manager.send_progress(session_id, status_data)
        await create_status_json("4", "finished", status_data)

        logger.info(f"Agent4 completed audio generation for session {session_id}")

        # Compile all pipeline data for Agent5
        pipeline_data = {
            "agent2_data": agent2_data or {},
            "script": script,
            "voice": voice,
            "audio_option": audio_option,
            "audio_data": result_data
        }

        # Trigger Agent5 with all pipeline data
        from app.agents.agent_5 import agent_5_process
        await agent_5_process(
            websocket_manager,
            user_id,
            session_id,
            supersessionid,
            storage_service,
            pipeline_data=pipeline_data
        )

        return result_data

    except Exception as e:
        # Report error status and stop pipeline
        error_data = {
            "agentnumber": "Agent4",
            "userID": user_id,
            "sessionID": session_id,
            "supersessionID": supersessionid,
            "status": "error",
            "error": str(e),
            "reason": f"Agent4 failed: {type(e).__name__}",
            "timestamp": int(time.time() * 1000)
        }
        await websocket_manager.send_progress(session_id, error_data)
        await create_status_json("4", "error", error_data)
        logger.error(f"Agent4 failed for session {session_id}: {e}")
        raise  # Stop pipeline on error
